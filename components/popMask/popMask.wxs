var deltaY = 0,
    pointY = 0,
    pointList = [],
    lastPointerId = 0,
    lastDeltaY = 0,
    hideLength = 40,
    closeTouch = false,
    isAnimating = false,
    endTime = '';

function touchstart(e) {
    var dataSet = e.instance.getDataset();
    closeTouch = dataSet.closetouch;
    hideLength = dataSet.hidelength;
    isAnimating = dataSet.isanimating;
    if (endTime && !isAnimating && (getDate() - endTime < 250)) { //关闭有动画效果200ms，这里防止再次触发
        isAnimating = true;
    } else {
        endTime = '';
    }
    if (closeTouch || isAnimating) {
        return
    }
    var touches = e.changedTouches;
    pointY = touches[0].pageY; //当前手指坐标
    lastPointerId = touches[0].identifier;
    lastDeltaY = deltaY + 0;
    if (e.touches.length == 1) {
        pointList = [lastPointerId];
    } else {
        pointList.push(lastPointerId);
    }
}

function touchmove(e, ins) {
    if (closeTouch || isAnimating) {
        return
    }
    var touch = e.changedTouches[0];
    var hasTouch = false;
    if (e.changedTouches.length > 1) {
        for (var i = e.changedTouches.length - 1; i >= 0; i--) {
            if (e.changedTouches[i].identifier == lastPointerId) {
                touch = e.changedTouches[i];
                hasTouch = true;
                break;
            }
        }
    } else if (lastPointerId != touch.identifier) {
        return
    }
    //坑，压缩代码有问题，只能这样写了
    if (e.changedTouches.length > 1 && !hasTouch) {
        return
    }
    deltaY = lastDeltaY + touch.pageY - pointY;
    if (deltaY < 0) deltaY = 0;
    ins.selectComponent('.popup-mask-box').setStyle('-webkit-transform:translate3d(0, ' + deltaY + 'px, 0);transform:translate3d(0, ' + deltaY + 'px, 0);-webkit-transition:none;transition:none;');
}

function touchend(e, ins) {
    if (closeTouch || deltaY == 0 || isAnimating) {
        return
    }
    e.changedTouches.map(function (item) {
        var idx = pointList.indexOf(item.identifier);
        if (idx != -1) {
            pointList.splice(idx, 1);
        }
    })
    var touches = e.touches.filter(function (item) {
        return pointList.indexOf(item.identifier) != -1
    });
    if (touches.length) {
        var lastTouches = touches[touches.length - 1];
        lastPointerId = lastTouches.identifier;
        pointY = lastTouches.pageY;
        lastDeltaY = deltaY + 0;
        return
    }
    if (deltaY >= hideLength) {
        endTime = getDate();
        ins.callMethod('_cancel');
    } else {
        ins.selectComponent('.popup-mask-box').setStyle('-webkit-transform:translate3d(0, 0, 0);transform:translate3d(0, 0, 0);-webkit-transition:transform 200ms ease-out;transition:transform 200ms ease-out;');
    }
    lastDeltaY = 0;
    lastPointerId = 0;
    pointY = 0;
    deltaY = 0;
    pointList = [];
}

module.exports = {
    propObserver: function (newValue, oldValue, ins) {
        ins.selectComponent('.popup-mask-box').setStyle(newValue);
    },
    _onStart: touchstart,
    _onMove: touchmove,
    _onEnd: touchend
}